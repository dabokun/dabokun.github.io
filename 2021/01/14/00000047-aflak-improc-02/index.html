<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>ほしよみ社会塵のブログ</title><meta name="description" content="やっていきます"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/avatar.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

はじめに今回も前回に引き続き自作プログラムでベーシックな画像処理まがいのことをしていきます．今回のお品書きはこちらです．

カラーヒストグラム表示
RGB→HSV変換とHSV→RGBのマッピング
トーンカーブ機能の作成



その1. カラーヒストグラムの表示RGB 3チャンネルではなく1チャンネルのみのヒストグラムは既にできていたので，ちょちょっと改造です．カラー画像と認識したデータに対する出力の右側にヒストグラムを表示するようにしました．
pub(crate) fn show_hist_color(&amp;amp;self, ui: &amp;amp;Ui, pos: [f32; 2], size: [f32; 2]) &amp;#123;
  let vmin = 0.0;
  let vmax = 65535.0;
.."><meta property="og:url" content="http://dabokun.github.io/2021/01/14/00000047-aflak-improc-02/"><meta property="og:title" content="ほしよみ社会塵のブログ"><meta property="og:type" content="article"><meta property="og:description" content="

はじめに今回も前回に引き続き自作プログラムでベーシックな画像処理まがいのことをしていきます．今回のお品書きはこちらです．

カラーヒストグラム表示
RGB→HSV変換とHSV→RGBのマッピング
トーンカーブ機能の作成
"><meta property="name" content="

はじめに今回も前回に引き続き自作プログラムでベーシックな画像処理まがいのことをしていきます．今回のお品書きはこちらです．

カラーヒストグラム表示
RGB→HSV変換とH..."><meta property="og:image" content="http://dabokun.github.io/null"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@astrodabo"><meta property="og:site_name" content="ほしよみ社会塵のブログ"><meta property="og:locale" content="ja_JP"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ほしよみ社会塵のブログ" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ほしよみ社会塵のブログ</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">自作プログラムで画像処理（カラーヒストグラム表示～トーンカーブ作成まで）</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/hdr_photo">HDR Astrophoto</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/hdr_photo">HDR Astrophoto</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><span class="toc-text">はじめに</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%9D%E3%81%AE1-%E3%82%AB%E3%83%A9%E3%83%BC%E3%83%92%E3%82%B9%E3%83%88%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E8%A1%A8%E7%A4%BA"><span class="toc-text">その1. カラーヒストグラムの表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%9D%E3%81%AE2-RGB%E2%86%92HSV%E5%A4%89%E6%8F%9B"><span class="toc-text">その2. RGB→HSV変換</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%83%88%E3%83%BC%E3%83%B3%E3%82%AB%E3%83%BC%E3%83%96%E3%81%AE%E4%BD%9C%E6%88%90"><span class="toc-text">トーンカーブの作成</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Rust"><i class="tag post-item-tag">Rust</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">自作プログラムで画像処理（カラーヒストグラム表示～トーンカーブ作成まで）</h1><time class="has-text-grey" datetime="2021-01-14T14:58:45.000Z">2021-01-14</time><article class="mt-2 post-content"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<h3 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h3><p>今回も<a href="/2021/01/04/00000046-aflak-improc-01/">前回</a>に引き続き自作プログラムでベーシックな画像処理まがいのことをしていきます．<br>今回のお品書きはこちらです．</p>
<ul>
<li><strong>カラーヒストグラム表示</strong></li>
<li><strong>RGB→HSV変換とHSV→RGBのマッピング</strong></li>
<li><strong>トーンカーブ機能の作成</strong></li>
</ul>
<span id="more"></span>

<h4 id="その1-カラーヒストグラムの表示"><a href="#その1-カラーヒストグラムの表示" class="headerlink" title="その1. カラーヒストグラムの表示"></a>その1. カラーヒストグラムの表示</h4><p>RGB 3チャンネルではなく1チャンネルのみのヒストグラムは既にできていたので，ちょちょっと改造です．カラー画像と認識したデータに対する出力の右側にヒストグラムを表示するようにしました．</p>
<pre><code class="hljs Rust"><span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_hist_color</span>(&amp;<span class="hljs-keyword">self</span>, ui: &amp;Ui, pos: [<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>], size: [<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>]) &#123;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">vmin</span> = <span class="hljs-number">0.0</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">vmax</span> = <span class="hljs-number">65535.0</span>;

  <span class="hljs-keyword">const</span> FILL_COLOR_R: <span class="hljs-type">u32</span> = <span class="hljs-number">0x5500_00FF</span>;
  <span class="hljs-keyword">const</span> FILL_COLOR_G: <span class="hljs-type">u32</span> = <span class="hljs-number">0x5500_FF00</span>;
  <span class="hljs-keyword">const</span> FILL_COLOR_B: <span class="hljs-type">u32</span> = <span class="hljs-number">0x55FF_0000</span>;
  <span class="hljs-keyword">const</span> BORDER_COLOR: <span class="hljs-type">u32</span> = <span class="hljs-number">0xFF00_0000</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">hist</span> = <span class="hljs-keyword">self</span>.image.<span class="hljs-title function_ invoke__">hist_color</span>();
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>((max_count_r, max_count_g, max_count_b)) = hist
      .<span class="hljs-title function_ invoke__">iter</span>()
      .<span class="hljs-title function_ invoke__">map</span>(|bin| (bin[<span class="hljs-number">0</span>].count, bin[<span class="hljs-number">1</span>].count, bin[<span class="hljs-number">2</span>].count))
      .<span class="hljs-title function_ invoke__">max</span>()
  &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">draw_list</span> = ui.<span class="hljs-title function_ invoke__">get_window_draw_list</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">max_count</span> = max_count_r.<span class="hljs-title function_ invoke__">max</span>(max_count_g).<span class="hljs-title function_ invoke__">max</span>(max_count_b);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x_pos</span> = pos[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> &#123;
      <span class="hljs-keyword">for</span> <span class="hljs-variable">bin</span> <span class="hljs-keyword">in</span> hist &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">y_pos</span> = pos[<span class="hljs-number">1</span>] + size[<span class="hljs-number">1</span>] / (vmax - vmin) * (vmax - bin[i].start);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">y_pos_end</span> = pos[<span class="hljs-number">1</span>] + size[<span class="hljs-number">1</span>] / (vmax - vmin) * (vmax - bin[i].end);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = size[<span class="hljs-number">0</span>]
          * <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.hist_logscale &#123;
            (bin[i].count <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>).<span class="hljs-title function_ invoke__">log10</span>() / (max_count <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>).<span class="hljs-title function_ invoke__">log10</span>()
          &#125; <span class="hljs-keyword">else</span> &#123;
            (bin[i].count <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>) / (max_count <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>)
          &#125;;
          draw_list
            .<span class="hljs-title function_ invoke__">add_rect</span>(
              [x_pos + size[<span class="hljs-number">0</span>] - length, y_pos],
              [x_pos + size[<span class="hljs-number">0</span>], y_pos_end],
              <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;
                FILL_COLOR_R
              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &#123;
                FILL_COLOR_G
              &#125; <span class="hljs-keyword">else</span> &#123;
                FILL_COLOR_B
              &#125;,
            )
            .<span class="hljs-title function_ invoke__">filled</span>(<span class="hljs-literal">true</span>)
            .<span class="hljs-title function_ invoke__">build</span>();
      &#125;
    &#125;
    draw_list
      .<span class="hljs-title function_ invoke__">add_rect</span>(pos, [pos[<span class="hljs-number">0</span>] + size[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>] + size[<span class="hljs-number">1</span>]], BORDER_COLOR)
      .<span class="hljs-title function_ invoke__">build</span>();
  &#125;
&#125;</code></pre>
<p>するとこんな感じにカラー画像の横に出てきます．<br><img src="/images/00000047-aflak-improc-02/tw01.jpg" alt="カラーヒストグラムの表示"></p>
<h4 id="その2-RGB→HSV変換"><a href="#その2-RGB→HSV変換" class="headerlink" title="その2. RGB→HSV変換"></a>その2. RGB→HSV変換</h4><p><a target="_blank" rel="noopener" href="https://www.peko-step.com/tool/hsvrgb.html">このサイト</a>によると，画素の RGB それぞれの輝度値$$R, G, B$$として，<br>$$Max &#x3D; \max(R, G, B), Min &#x3D; \min(R, G, B)$$<br>$$H &#x3D; 60 * ((G - B) &#x2F; (Max - Min)) ,; \max(R, G, B) &#x3D; R$$<br>$$H &#x3D; 60 * ((B - R) &#x2F; (Max - Min)) + 120 ,; \max(R, G, B) &#x3D; G$$<br>$$H &#x3D; 60 * ((R - G) &#x2F; (Max - Min)) + 240 ,; \max(R, G, B) &#x3D; B$$<br>$$S &#x3D; (Max - Min) &#x2F; Max$$<br>$$V &#x3D; Max$$<br>と計算できるっぽいのでこれに習っていきます．上の例だと色相は360度で表現してますが，後々 RGB に再マッピングすることを考えて 16bit の範囲に再スケールしておきます．</p>
<pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_color_image_to_hsv</span>(image: &amp;WcsArray) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;IOValue, IOErr&gt; &#123;
  dim_is!(image, <span class="hljs-number">3</span>)?;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">image</span> = image.<span class="hljs-title function_ invoke__">scalar</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">out</span> = image.<span class="hljs-title function_ invoke__">clone</span>();
  <span class="hljs-keyword">for</span> (j, slice) <span class="hljs-keyword">in</span> image.<span class="hljs-title function_ invoke__">axis_iter</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>)).<span class="hljs-title function_ invoke__">enumerate</span>() &#123;
    <span class="hljs-keyword">for</span> (i, data) <span class="hljs-keyword">in</span> slice.<span class="hljs-title function_ invoke__">axis_iter</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>)).<span class="hljs-title function_ invoke__">enumerate</span>() &#123;
      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hue</span> = <span class="hljs-number">0.0</span>;
      <span class="hljs-keyword">let</span> <span class="hljs-variable">max</span> = data[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">max</span>(data[<span class="hljs-number">1</span>]).<span class="hljs-title function_ invoke__">max</span>(data[<span class="hljs-number">2</span>]);
      <span class="hljs-keyword">let</span> <span class="hljs-variable">min</span> = data[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">min</span>(data[<span class="hljs-number">1</span>]).<span class="hljs-title function_ invoke__">min</span>(data[<span class="hljs-number">2</span>]);
      <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] &gt;= data[<span class="hljs-number">1</span>] &amp;&amp; data[<span class="hljs-number">0</span>] &gt;= data[<span class="hljs-number">2</span>] &#123;
        hue = <span class="hljs-number">60.0</span> * ((data[<span class="hljs-number">1</span>] - data[<span class="hljs-number">2</span>]) / (max - min));
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> data[<span class="hljs-number">1</span>] &gt;= data[<span class="hljs-number">0</span>] &amp;&amp; data[<span class="hljs-number">1</span>] &gt;= data[<span class="hljs-number">2</span>] &#123;
        hue = <span class="hljs-number">60.0</span> * ((data[<span class="hljs-number">2</span>] - data[<span class="hljs-number">0</span>]) / (max - min)) + <span class="hljs-number">120.0</span>;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> data[<span class="hljs-number">2</span>] &gt;= data[<span class="hljs-number">0</span>] &amp;&amp; data[<span class="hljs-number">2</span>] &gt;= data[<span class="hljs-number">1</span>] &#123;
        hue = <span class="hljs-number">60.0</span> * ((data[<span class="hljs-number">0</span>] - data[<span class="hljs-number">1</span>]) / (max - min)) + <span class="hljs-number">240.0</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Unreachable&quot;</span>);
      &#125;
      <span class="hljs-keyword">if</span> hue &lt; <span class="hljs-number">0.0</span> &#123;
        hue += <span class="hljs-number">360.0</span>;
      &#125;
      hue = hue / <span class="hljs-number">360.0</span> * <span class="hljs-number">65535.0</span>;
      out[[<span class="hljs-number">0</span>, j, i]] = hue;
      out[[<span class="hljs-number">1</span>, j, i]] = (max - min) / max * <span class="hljs-number">65535.0</span>;
      out[[<span class="hljs-number">2</span>, j, i]] = max;
    &#125;
  &#125;
  <span class="hljs-title function_ invoke__">Ok</span>(IOValue::<span class="hljs-title function_ invoke__">Image</span>(WcsArray::<span class="hljs-title function_ invoke__">from_array</span>(Dimensioned::<span class="hljs-title function_ invoke__">new</span>(
    out,
    Unit::<span class="hljs-literal">None</span>,
  ))))
&#125;</code></pre>
<p>まずは HSV の値が入っている三次元データをスライスして見てみるとこんな感じの強度分布図になります．<br><img src="/images/00000047-aflak-improc-02/01.jpg" alt="HSV の強度分布図"></p>
<p>上のビジュアルプログラムについて少し説明を書いておくと，<strong>まず上記の計算式から 0番目に色相のマップ，1番目に彩度のマップ，2番目に明度のマップが入っているような三次元データを作ります（図の赤枠）．この三次元データは右側に流れていき，スライスすることでそれぞれのマップデータ（二次元）を得ています．</strong></p>
<p>次にこれらをRGBに再マッピングしてみます．次のような，三つの二次元のチャンネルデータを受け取ってカラー画像（三次元データ）を出力するようなノードを作ります．</p>
<pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_generate_color_image_from_channel</span>(
    image_r: &amp;WcsArray,
    image_g: &amp;WcsArray,
    image_b: &amp;WcsArray,
) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;IOValue, IOErr&gt; &#123;
  dim_is!(image_r, <span class="hljs-number">2</span>)?;
  dim_is!(image_g, <span class="hljs-number">2</span>)?;
  dim_is!(image_b, <span class="hljs-number">2</span>)?;
  are_same_dim!(image_r, image_b)?;
  are_same_dim!(image_b, image_g)?;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">dim</span> = image_r.<span class="hljs-title function_ invoke__">scalar</span>().<span class="hljs-title function_ invoke__">dim</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-variable">dim</span> = dim.<span class="hljs-title function_ invoke__">as_array_view</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">colorimage</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">3</span> * dim[<span class="hljs-number">0</span>] * dim[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">for</span> &amp;data <span class="hljs-keyword">in</span> image_r.<span class="hljs-title function_ invoke__">scalar</span>().<span class="hljs-title function_ invoke__">iter</span>() &#123;
    colorimage.<span class="hljs-title function_ invoke__">push</span>(data);
  &#125;
  <span class="hljs-keyword">for</span> &amp;data <span class="hljs-keyword">in</span> image_g.<span class="hljs-title function_ invoke__">scalar</span>().<span class="hljs-title function_ invoke__">iter</span>() &#123;
    colorimage.<span class="hljs-title function_ invoke__">push</span>(data);
  &#125;
  <span class="hljs-keyword">for</span> &amp;data <span class="hljs-keyword">in</span> image_b.<span class="hljs-title function_ invoke__">scalar</span>().<span class="hljs-title function_ invoke__">iter</span>() &#123;
    colorimage.<span class="hljs-title function_ invoke__">push</span>(data);
  &#125;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">img</span> = Array::<span class="hljs-title function_ invoke__">from_shape_vec</span>((<span class="hljs-number">3</span>, dim[<span class="hljs-number">0</span>], dim[<span class="hljs-number">1</span>]), colorimage).<span class="hljs-title function_ invoke__">unwrap</span>();

  <span class="hljs-title function_ invoke__">Ok</span>(IOValue::<span class="hljs-title function_ invoke__">Image</span>(WcsArray::<span class="hljs-title function_ invoke__">from_array</span>(Dimensioned::<span class="hljs-title function_ invoke__">new</span>(
    img.<span class="hljs-title function_ invoke__">into_dyn</span>(),
    Unit::<span class="hljs-literal">None</span>,
  ))))
&#125;</code></pre>
<p>とりあえずHをR，SをG，VをBにそのままマッピングすると次のようになりました．<strong>エッジの接続関係（下図の黄緑枠）を変えることで，別の組み合わせにする（たとえばHをB，SをR，VをGなど）ことも自由自在</strong>です．<br><img src="/images/00000047-aflak-improc-02/02.jpg" alt="HSV→RGBへのマッピング"><br>上の図で，HをR，SをG，VをBに接続していることが表現されています．</p>
<h4 id="トーンカーブの作成"><a href="#トーンカーブの作成" class="headerlink" title="トーンカーブの作成"></a>トーンカーブの作成</h4><p>お次はトーンカーブ．ゼロから作らなければならなかったので，これが一番面倒でした．まずはインタフェースからのんびり作っていきます．</p>
<pre><code class="hljs Rust"><span class="hljs-meta">#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ToneCurveState</span> &#123;
  arr: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">f32</span>&gt;,
  cp: <span class="hljs-type">Vec</span>&lt;[<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>]&gt;,
  adding: <span class="hljs-type">Option</span>&lt;[<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>]&gt;,
  pushed: <span class="hljs-type">bool</span>,
  moving: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt;,
  deleting: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt;,
  x_clicking: <span class="hljs-type">usize</span>,
  is_dragging: <span class="hljs-type">bool</span>,
&#125;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">ToneCurveState</span> &#123;
  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
    <span class="hljs-comment">/*省略*/</span>
  &#125;

  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">control_points</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;[<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>]&gt; &#123;
    <span class="hljs-keyword">self</span>.cp
  &#125;

  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">array</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">f32</span>&gt; &#123;
    <span class="hljs-keyword">self</span>.arr
  &#125;
&#125;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ToneCurveState</span> &#123;
  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&amp;<span class="hljs-keyword">self</span>, val: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">cp1</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">control_points</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">cp2</span> = val.<span class="hljs-title function_ invoke__">control_points</span>();
    cp1 == cp2
  &#125;
&#125;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">UiToneCurve</span> &#123;
  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_curve</span>(cp: &amp;<span class="hljs-type">Vec</span>&lt;[<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>]&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">f32</span>&gt;;
  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">tone_curve</span>(
    &amp;<span class="hljs-keyword">self</span>,
    state: &amp;<span class="hljs-keyword">mut</span> ToneCurveState,
    draw_list: &amp;WindowDrawList,
  ) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Option</span>&lt;ToneCurveState&gt;&gt;;
&#125;

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;ui</span>&gt; UiToneCurve <span class="hljs-keyword">for</span> <span class="hljs-title class_">Ui</span>&lt;<span class="hljs-symbol">&#x27;ui</span>&gt; &#123;
  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_curve</span>(cp: &amp;<span class="hljs-type">Vec</span>&lt;[<span class="hljs-type">f32</span>; <span class="hljs-number">2</span>]&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">f32</span>&gt; &#123;
    <span class="hljs-comment">/*省略*/</span>
  &#125;

  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">tone_curve</span>(
    &amp;<span class="hljs-keyword">self</span>,
    state: &amp;<span class="hljs-keyword">mut</span> ToneCurveState,
    draw_list: &amp;WindowDrawList,
  ) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Option</span>&lt;ToneCurveState&gt;&gt; &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">cursor_screen_pos</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">mouse_pos</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">io</span>().mouse_pos;
    <span class="hljs-keyword">let</span> [mouse_x, mouse_y] = [mouse_pos[<span class="hljs-number">0</span>] - p[<span class="hljs-number">0</span>] - <span class="hljs-number">5.0</span>, mouse_pos[<span class="hljs-number">1</span>] - p[<span class="hljs-number">1</span>] - <span class="hljs-number">5.0</span>];
    state.arr = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">create_curve</span>(&amp;state.cp);
    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">invisible_button</span>(im_str!(<span class="hljs-string">&quot;tone_curve&quot;</span>), [<span class="hljs-number">410.0</span>, <span class="hljs-number">410.0</span>]);
    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">set_cursor_screen_pos</span>(p);
    PlotLines::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>, im_str!(<span class="hljs-string">&quot;Tone Curve Test&quot;</span>), &amp;state.arr)
        .<span class="hljs-title function_ invoke__">graph_size</span>([<span class="hljs-number">410.0</span>, <span class="hljs-number">410.0</span>])
        .<span class="hljs-title function_ invoke__">scale_min</span>(<span class="hljs-number">0.0</span>)
        .<span class="hljs-title function_ invoke__">scale_max</span>(<span class="hljs-number">256.0</span>)
        .<span class="hljs-title function_ invoke__">build</span>();
    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">set_cursor_screen_pos</span>(p);
    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">invisible_button</span>(im_str!(<span class="hljs-string">&quot;tone_curve&quot;</span>), [<span class="hljs-number">410.0</span>, <span class="hljs-number">410.0</span>]);
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(adding) = state.adding &#123;
      <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = adding[<span class="hljs-number">0</span>] * <span class="hljs-number">400.0</span> + <span class="hljs-number">5.0</span> + p[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (<span class="hljs-number">1.0</span> - adding[<span class="hljs-number">1</span>]) * <span class="hljs-number">400.0</span> + <span class="hljs-number">5.0</span> + p[<span class="hljs-number">1</span>];
      draw_list.<span class="hljs-title function_ invoke__">add_circle</span>([x, y], <span class="hljs-number">5.0</span>, <span class="hljs-number">0xFF00_FFFF</span>).<span class="hljs-title function_ invoke__">build</span>();
    &#125;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;state.cp &#123;
      <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = i[<span class="hljs-number">0</span>] * <span class="hljs-number">400.0</span> + <span class="hljs-number">5.0</span> + p[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (<span class="hljs-number">1.0</span> - i[<span class="hljs-number">1</span>]) * <span class="hljs-number">400.0</span> + <span class="hljs-number">5.0</span> + p[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (x - mouse_pos[<span class="hljs-number">0</span>]) * (x - mouse_pos[<span class="hljs-number">0</span>]) + (y - mouse_pos[<span class="hljs-number">1</span>]) * (y - mouse_pos[<span class="hljs-number">1</span>])
          &lt; <span class="hljs-number">25.0</span>
      &#123;
        draw_list.<span class="hljs-title function_ invoke__">add_circle</span>([x, y], <span class="hljs-number">5.0</span>, <span class="hljs-number">0xFF00_00FF</span>).<span class="hljs-title function_ invoke__">build</span>();
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_mouse_clicked</span>(MouseButton::Left) &amp;&amp; state.adding == <span class="hljs-literal">None</span> &#123;
          state.moving = <span class="hljs-title function_ invoke__">Some</span>(counter);
        &#125;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_mouse_clicked</span>(MouseButton::Right) &#123;
          <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">open_popup</span>(im_str!(<span class="hljs-string">&quot;delete-control-point&quot;</span>));
          state.deleting = <span class="hljs-title function_ invoke__">Some</span>(counter);
        &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
        draw_list.<span class="hljs-title function_ invoke__">add_circle</span>([x, y], <span class="hljs-number">5.0</span>, <span class="hljs-number">0xFFFF_FFFF</span>).<span class="hljs-title function_ invoke__">build</span>();
      &#125;
      counter += <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">popup</span>(im_str!(<span class="hljs-string">&quot;delete-control-point&quot;</span>), || &#123;
      <span class="hljs-keyword">if</span> MenuItem::<span class="hljs-title function_ invoke__">new</span>(im_str!(<span class="hljs-string">&quot;Delete Control Point&quot;</span>)).<span class="hljs-title function_ invoke__">build</span>(<span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(key) = state.deleting &#123;
          state.cp.<span class="hljs-title function_ invoke__">remove</span>(key);
          state.deleting = <span class="hljs-literal">None</span>;
        &#125;
      &#125;
    &#125;);
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_item_hovered</span>() &#123;
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_mouse_clicked</span>(MouseButton::Left) &amp;&amp; state.moving == <span class="hljs-literal">None</span> &#123;
        <span class="hljs-keyword">if</span> !state.is_dragging &#123;
          state.is_dragging = <span class="hljs-literal">true</span>;
        &#125;
      &#125;
      <span class="hljs-keyword">if</span> state.is_dragging &#123;
        <span class="hljs-keyword">if</span> state.pushed == <span class="hljs-literal">false</span> &#123;
          state.pushed = <span class="hljs-literal">true</span>;
          state.cp.<span class="hljs-title function_ invoke__">push</span>([mouse_x / <span class="hljs-number">400.0</span>, (<span class="hljs-number">400.0</span> - mouse_y) / <span class="hljs-number">400.0</span>]);
        &#125;
        state.adding = <span class="hljs-title function_ invoke__">Some</span>([mouse_x / <span class="hljs-number">400.0</span>, (<span class="hljs-number">400.0</span> - mouse_y) / <span class="hljs-number">400.0</span>]);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">lastidx</span> = state.cp.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>;
        state.cp[lastidx] = state.adding.<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-keyword">if</span> state.x_clicking &gt; <span class="hljs-number">255</span> &#123;
          state.x_clicking = <span class="hljs-number">255</span>;
        &#125;
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_mouse_down</span>(MouseButton::Left) &#123;
          state.cp.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| a[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;b[<span class="hljs-number">0</span>]).<span class="hljs-title function_ invoke__">unwrap</span>());
          state.adding = <span class="hljs-literal">None</span>;
          state.is_dragging = <span class="hljs-literal">false</span>;
          state.pushed = <span class="hljs-literal">false</span>;
        &#125;
      &#125;
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(key) = state.moving &#123;
        state.cp[key] = [mouse_x / <span class="hljs-number">400.0</span>, (<span class="hljs-number">400.0</span> - mouse_y) / <span class="hljs-number">400.0</span>];
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_mouse_down</span>(MouseButton::Left) &#123;
          state.moving = <span class="hljs-literal">None</span>;
        &#125;
      &#125;
    &#125;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = state.<span class="hljs-title function_ invoke__">clone</span>();
    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">Some</span>(state))
  &#125;
&#125;</code></pre>
<p><video src="https://dabokun.github.io/images/00000047-aflak-improc-02/tw01.mp4" width="674" height="360" controls></video><br>まだハードコードされているところとかがあり，要修正ですが貼っておきます．曲線の計算には現在 <a target="_blank" rel="noopener" href="http://naochang.me/?p=1119">Catmull-Rom Spline 曲線</a>を使っています．state にはコントロールポイントやルックアップテーブルの配列データ（現在大きさは256，0.0～256.0までの値が格納）が入っていて，次のように使います．</p>
<pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tone_curve_state</span> = ui.<span class="hljs-title function_ invoke__">tone_curve</span>(&amp;<span class="hljs-keyword">mut</span> state, &amp;draw_list);
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(state) = tone_curve_state &#123;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = state.<span class="hljs-title function_ invoke__">unwrap</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-variable">control_points</span> = state.<span class="hljs-title function_ invoke__">control_points</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-variable">array</span> = state.<span class="hljs-title function_ invoke__">array</span>();
&#125;</code></pre>
<p>次に，トーンカーブのデータ型を作って，画像データとトーンカーブデータから適用後の画像を出力するノードを作って完成です．<br>トーンカーブデータのところは省略します．</p>
<pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_apply_tone_curve</span>(image: &amp;WcsArray, tone_curve: ToneCurveState) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;IOValue, IOErr&gt; &#123;
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">image_arr</span> = image.<span class="hljs-title function_ invoke__">scalar</span>().<span class="hljs-title function_ invoke__">clone</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-variable">table</span> = tone_curve.<span class="hljs-title function_ invoke__">array</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-variable">table_size</span> = table.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>;
  image_arr.<span class="hljs-title function_ invoke__">par_map_inplace</span>(|v| &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">key</span> = (*v * table_size <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span> / <span class="hljs-number">65535.0</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = <span class="hljs-number">65535.0</span> * table[key] / table_size <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>;
    *v = value;
  &#125;);
  <span class="hljs-title function_ invoke__">Ok</span>(IOValue::<span class="hljs-title function_ invoke__">Image</span>(WcsArray::<span class="hljs-title function_ invoke__">from_array</span>(Dimensioned::<span class="hljs-title function_ invoke__">new</span>(
    image_arr,
    Unit::<span class="hljs-literal">None</span>,
  ))))
&#125;</code></pre>
<p><video src="https://dabokun.github.io/images/00000047-aflak-improc-02/tw02.mp4" width="674" height="360" controls></video><br>ちなみに par_map_inplace という関数は ndarray_parallel という crate にあるもので，中の計算を並列処理してくれます．<br>普通に map で計算する場合と時間を比較するとこんな感じです．</p>
<p><img src="/images/00000047-aflak-improc-02/tw02.png" alt="並列処理のコード">画像にて失礼…．</p>
<p><img src="/images/00000047-aflak-improc-02/tw03.png" alt="実際にparallelのほうが速くなっている">実行結果はこんな漢字です．<br>結構速くなってますね．他にも直せるところがあると思っています．</p>
<p>さて，数日かけて色々とやりましたが次は何をしましょうか．悩み中です．しばらくは改善とリファクタリングですかね…．<br>なにか作って欲しいものやアドバイスがありましたらブログや Twitter で募集しております．<br>それでは．</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/02/09/00000048-fsq-ret-qhy268c/" title="ごほーこく"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: ごほーこく</span></a><a class="button is-default" href="/2021/01/04/00000046-aflak-improc-01/" title="自作プログラムで画像処理（Raw展開～ノイズ解析まで）"><span class="has-text-weight-semibold">Next: 自作プログラムで画像処理（Raw展開～ノイズ解析まで）</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="dabokun/dabokun.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/astrodabo"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/dabokun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> dabokun 2025</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>