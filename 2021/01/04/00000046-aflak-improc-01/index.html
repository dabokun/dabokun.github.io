<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>ほしよみ社会塵のブログ</title><meta name="description" content="やっていきます"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="はじめにこんにちは．あけましておめでとうございます．今年は自作プログラムの天体画像処理機能を充実させたいという思いがあったので，年末から三が日にかけて，少しだけ進めていました．


やっていくぞまだ特に「天体写真の画像処理用途」の機能を実装していなかった私の研究用プログラムということで，初回である今回の目標は

（複数の）Raw 画像を読込み
位置合わせなしコンポジット（平均値，中央値，分散，標準偏差などの統計値計算）
（主にダークデータの）ノイズ解析用 scatterplots 生成

となります．特にノイズ解析ではあぷらなーとさんがよくダークデータのノイズ解析をしてらっしゃいますので，あんな感じのことができればいいかなということになります．プログラムの全般的な詳しい機能の紹介は，以前書いたコンセプトの記.."><meta property="og:url" content="http://dabokun.github.io/2021/01/04/00000046-aflak-improc-01/"><meta property="og:title" content="ほしよみ社会塵のブログ"><meta property="og:type" content="article"><meta property="og:description" content="はじめにこんにちは．あけましておめでとうございます．今年は自作プログラムの天体画像処理機能を充実させたいという思いがあったので，年末から三が日にかけて，少しだけ進めていました．"><meta property="name" content="はじめにこんにちは．あけましておめでとうございます．今年は自作プログラムの天体画像処理機能を充実させたいという思いがあったので，年末から三が日にかけて，少しだけ進めていました．"><meta property="og:image" content="http://dabokun.github.io/null"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@astrodabo"><meta property="og:site_name" content="ほしよみ社会塵のブログ"><meta property="og:locale" content="ja_JP"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ほしよみ社会塵のブログ" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ほしよみ社会塵のブログ</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">自作プログラムで画像処理（Raw展開～ノイズ解析まで）</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/null">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/null">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><span class="toc-text">はじめに</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%82%84%E3%81%A3%E3%81%A6%E3%81%84%E3%81%8F%E3%81%9E"><span class="toc-text">やっていくぞ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%9D%E3%81%AE1-Raw%E3%82%92%E9%96%8B%E3%81%8F%EF%BC%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%91%E3%82%B9%E7%BE%A4%E2%86%92%E4%B8%89%E6%AC%A1%E5%85%83%E3%83%87%E3%83%BC%E3%82%BF%EF%BC%89"><span class="toc-text">その1. Rawを開く（ファイルパス群→三次元データ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%9D%E3%81%AE2-%E7%B5%B1%E8%A8%88%E5%80%A4%E8%A8%88%E7%AE%97%EF%BC%88%E4%B8%89%E6%AC%A1%E5%85%83%E3%83%87%E3%83%BC%E3%82%BF%E2%86%92%E4%BA%8C%E6%AC%A1%E5%85%83%E3%83%87%E3%83%BC%E3%82%BF%EF%BC%89"><span class="toc-text">その2. 統計値計算（三次元データ→二次元データ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%9D%E3%81%AE3-%E3%83%AA%E3%82%B9%E3%83%88%E3%81%B8%E5%A4%89%E6%8F%9B"><span class="toc-text">その3. リストへ変換</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%9D%E3%81%AE4-scatterplots-%E3%81%AE%E6%8F%8F%E7%94%BB"><span class="toc-text">その4. scatterplots の描画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%8A%E3%81%BE%E3%81%91-Fits%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%82%AB%E3%83%A9%E3%83%BC%E7%94%BB%E5%83%8F%E8%A7%A3%E9%87%88"><span class="toc-text">おまけ. Fitsデータのカラー画像解釈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB"><span class="toc-text">おわりに</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Rust"><i class="tag post-item-tag">Rust</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">自作プログラムで画像処理（Raw展開～ノイズ解析まで）</h1><time class="has-text-grey" datetime="2021-01-04T10:16:24.000Z">2021-01-04</time><article class="mt-2 post-content"><h3 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h3><p>こんにちは．あけましておめでとうございます．今年は自作プログラムの天体画像処理機能を充実させたいという思いがあったので，年末から三が日にかけて，少しだけ進めていました．</p>
<span id="more"></span>

<h3 id="やっていくぞ"><a href="#やっていくぞ" class="headerlink" title="やっていくぞ"></a>やっていくぞ</h3><p>まだ特に「天体写真の画像処理用途」の機能を実装していなかった私の研究用プログラムということで，初回である今回の目標は</p>
<ul>
<li><strong>（複数の）Raw 画像を読込み</strong></li>
<li><strong>位置合わせなしコンポジット（平均値，中央値，分散，標準偏差などの統計値計算）</strong></li>
<li><strong>（主にダークデータの）ノイズ解析用 scatterplots 生成</strong></li>
</ul>
<p>となります．特にノイズ解析では<a target="_blank" rel="noopener" href="https://apranat.exblog.jp/31097570/">あぷらなーとさんがよくダークデータのノイズ解析をしてらっしゃいます</a>ので，あんな感じのことができればいいかなということになります．<br>プログラムの全般的な詳しい機能の紹介は，<a href="/2019/03/15/00000005-astrophoto-and-processing-2/">以前書いたコンセプトの記事</a>をご覧ください．</p>
<h4 id="その1-Rawを開く（ファイルパス群→三次元データ）"><a href="#その1-Rawを開く（ファイルパス群→三次元データ）" class="headerlink" title="その1. Rawを開く（ファイルパス群→三次元データ）"></a>その1. Rawを開く（ファイルパス群→三次元データ）</h4><p>まず，Raw を開くだけなら簡単です．<a href="/2019/06/04/00000009-rust-raw-loader-crate/">以前紹介した rawloader crate</a> を使用すれば開けます．<br>が，今回はコンポジットやノイズ解析をしたいので，複数枚の Raw 画像を読む必要があります．<br>これまでは一つの Path というノードで単一のデータファイルパスを表現していましたが，これを一つのノードで複数枚のリストが表現できるように改造する必要がありました．</p>
<p><strong><font color="red">これからコードをドバドバ貼っていきますが，自分のメモ代わりなので読み飛ばしてください．</font></strong></p>
<pre><code class="language-Rust">pub enum PATHS &#123;
    Nothing,
    FileList(Vec&lt;PathBuf&gt;),
&#125;
impl MenuBar for PATHS &#123;
    fn visualize&lt;F&gt;(&amp;self, ctx: OutputWindowCtx&lt;&#39;_, &#39;_, &#39;_, &#39;_, &#39;_, &#39;_, &#39;_, F&gt;)
    where
        F: glium::backend::Facade,
    &#123;
        ctx.ui.text_wrapped(&amp;im_str!(&quot;&#123;:?&#125;&quot;, self));
    &#125;
    /*省略*/
&#125;
IOValue::Paths(ref file) =&gt; &#123;
    match file &#123;
        primitives::PATHS::Nothing =&gt; None,
        primitives::PATHS::FileList(file) =&gt; &#123;
            if read_only &#123;
                None
            &#125; else &#123;
                let size = ui.item_rect_size();
                let mut ret = Ok(None);
                ChildWindow::new(im_str!(&quot;edit&quot;))
                    .size([size[0].max(400.0), 150.0])
                    .horizontal_scrollbar(true)
                    .build(ui, || &#123;
                        let mut hoge = false;
                        ret = ui.file_explorer(
                            TOP_FOLDER,
                            &amp;[
                                &quot;fits&quot;, &quot;fit&quot;, &quot;fts&quot;, &quot;cr2&quot;, &quot;CR2&quot;, &quot;RW2&quot;, &quot;rw2&quot;, &quot;nef&quot;, &quot;NEF&quot;,
                            ],
                            &amp;mut hoge,
                        );
                    &#125;);
                ui.text(im_str!(&quot;Selected Files:&quot;));
                for single_file in file &#123;
                    ui.text(single_file.to_str().unwrap_or(&quot;Unrepresentable path&quot;));
                &#125;
                if let Ok(Some(new_file)) = ret &#123;
                    let mut already_exist = false;
                    let mut key = 0;
                    for single_file in file &#123;
                        if *single_file == new_file &#123;
                            already_exist = true;
                            break;
                        &#125;
                        key += 1;
                    &#125;
                    if already_exist &#123;
                        let mut new_files = file.clone();
                        new_files.remove(key);
                        Some(IOValue::Paths(primitives::PATHS::FileList(
                            new_files.to_vec(),
                        )))
                    &#125; else &#123;
                        let mut new_files = file.clone();
                        new_files.push(new_file);
                        Some(IOValue::Paths(primitives::PATHS::FileList(
                            new_files.to_vec(),
                        )))
                    &#125;
                &#125; else &#123;
                    None
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>するとこんな感じに↓<br><img src="/images/00000046-aflak-improc-01/01.jpg" alt="Paths ノードでファイル複数のファイルを開く"><br>なんかカレントディレクトリの表示がおかしいですが，ちゃんと動作するので今はキニシナイ．</p>
<p>次に，この Path 改め Paths を受け取り，画像を展開して**三次元データ（0番目の軸で何枚目かというインデックス，1番目と2番目の軸で画像の輝度にアクセスできる）**を生成するノードを作ります．</p>
<pre><code class="language-Rust">cake_transform!(
    &quot;Open RAW file from a Paths.&quot;,
    0, 1, 0,
    open_raw&lt;IOValue, IOErr&gt;(path: Paths, n: Integer = 0) -&gt; Image &#123;
        if let PATHS::FileList(path) = path &#123;
            vec![run_open_raw(path.to_vec(), *n)]
        &#125; else &#123;
            vec![] //エラーを返そう
        &#125;
    &#125;
),

fn run_open_raw&lt;P: AsRef&lt;Path&gt;&gt;(path: Vec&lt;P&gt;, n: i64) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    let pathlist_len = path.len();
    let n = n as usize;
    precheck!(pathlist_len &gt; n)?;
    let mut imagecount = 0;
    let mut width = 0;
    let mut height = 0;
    let mut img = Vec::new();
    let mut openresult: Result&lt;IOValue, IOErr&gt; = Ok(IOValue::Integer(0));
    for single_path in path &#123;
        let image = rawloader::decode_file(single_path);
        match image &#123;
            Ok(image) =&gt; &#123;
                if imagecount == 0 &#123;
                    width = image.width;
                    height = image.height;
                &#125; else if width != image.width || height != image.height &#123;
                    eprintln!(&quot;Couldn&#39;t load images with different size images.\n&quot;); //エラーを返そう
                    break;
                &#125;
                if let rawloader::RawImageData::Integer(data) = image.data &#123;
                    for pix in data &#123;
                        img.push(pix as f32);
                    &#125;
                &#125; else &#123;
                    eprintln!(&quot;Don&#39;t know how to process non-integer raw files&quot;); //エラーを返そう
                    break;
                &#125;
            &#125;
            Err(err) =&gt; openresult = Err(IOErr::RawLoaderError(format!(&quot;&#123;:?&#125;&quot;, err))),
        &#125;
        imagecount += 1;
    &#125;
    match openresult &#123;
        Ok(_) =&gt; &#123;
            let img = Array::from_shape_vec((pathlist_len, height, width), img).unwrap();
            Ok(IOValue::Image(WcsArray::from_array(Dimensioned::new(
                img.into_dyn(),
                Unit::None,
            ))))
        &#125;
        Err(_) =&gt; openresult,
    &#125;
&#125;
</code></pre>
<p>cake_transform!マクロは，ノードを作るためのマクロです．引数で入力の型を指定し，-&gt;以降に出力の型を指定します．複数のデータを出力することも可能です．実際のデータは，<code>Vec&lt;Result&lt;IOValue, IOErr&gt;&gt;</code> という型のベクタで返しています．<br><video src="images/00000046-aflak-improc-01/tw01.mp4" width="674" height="360" controls></video><br>i番目の画像をスライスして取り出して表示できています．</p>
<p>これで統計値計算への準備が整いましたので，<strong>このタイミングであぷらなーとさんに連絡をし，Nikon D3 と D810A のダークデータをいただきました（妥当性の検証ができるのはとても助かります，ありがたいです）</strong>．とりあえず D3 のダーク Raw データが開けそうなので，こちらを使っていきます．</p>
<h4 id="その2-統計値計算（三次元データ→二次元データ）"><a href="#その2-統計値計算（三次元データ→二次元データ）" class="headerlink" title="その2. 統計値計算（三次元データ→二次元データ）"></a>その2. 統計値計算（三次元データ→二次元データ）</h4><p>三次元データを生成したら，<strong>各種統計値を計算する</strong>ノードを作っていきます．平均はすでに実装済みでしたし，分散と標準偏差も使っている <a target="_blank" rel="noopener" href="https://docs.rs/ndarray/0.14.0/ndarray/">ndarray</a> ライブラリに<a target="_blank" rel="noopener" href="https://docs.rs/ndarray/0.14.0/ndarray/struct.ArrayBase.html#method.mean_axis">計算するための関数</a>があります．中央値だけは，こちらで実装する必要がありそうだったので用意．</p>
<pre><code class="language-Rust">cake_transform!(
    &quot;Average for Image. Parameters: a=start, b=end (a &lt;= b).
Compute (Sum[k, &#123;a, b&#125;]image[k]) / (b - a). image[k] is k-th slice of image.
Second output contains (a + b) / 2
Third output contains (b - a)
Note: indices for a and b start from 0&quot;,
    1, 0, 0,
    average&lt;IOValue, IOErr&gt;(image: Image, start: Integer = 0, end: Integer = 1) -&gt; Image, Float, Float &#123;
        let middle = (*start as f32 + *end as f32) / 2.0;
        let width = *end as f32 - *start as f32;
        vec![run_average(image, *start, *end), Ok(IOValue::Float(middle)), Ok(IOValue::Float(width))]
    &#125;
),
cake_transform!(
    &quot;Variance for Image. Parameters: a=start, b=end (a &lt;= b).&quot;,
    1, 0, 0,
    variance&lt;IOValue, IOErr&gt;(image: Image, start: Integer = 0, end: Integer = 1) -&gt; Image&#123;
        vec![run_variance(image, *start, *end)]
    &#125;
),
cake_transform!(
    &quot;Stddev for Image. Parameters: a=start, b=end (a &lt;= b).&quot;,
    1, 0, 0,
    stddev&lt;IOValue, IOErr&gt;(image: Image, start: Integer = 0, end: Integer = 1) -&gt; Image&#123;
        vec![run_stddev(image, *start, *end)]
    &#125;
),
cake_transform!(
    &quot;Median for Image. Parameters: a=start, b=end (a &lt;= b).&quot;,
    1, 0, 0,
    median&lt;IOValue, IOErr&gt;(image: Image, start: Integer = 0, end: Integer = 1) -&gt; Image&#123;
        vec![run_median(image, *start, *end)]
    &#125;
),

fn reduce_array_slice&lt;F&gt;(image: &amp;WcsArray, start: i64, end: i64, f: F) -&gt; Result&lt;IOValue, IOErr&gt;
where
    F: Fn(&amp;ArrayViewD&lt;f32&gt;) -&gt; ArrayD&lt;f32&gt;,
&#123;
    let start = try_into_unsigned!(start)?;
    let end = try_into_unsigned!(end)?;
    is_sliceable!(image, start, end)?;

    let image_val = image.scalar();

    let slices = image_val.slice_axis(Axis(0), Slice::from(start..end));
    let raw = f(&amp;slices);
    let ndim = raw.ndim();

    let wrap_with_unit = image.make_slice(
        &amp;(0..ndim).map(|i| (i, 0.0, 1.0)).collect::&lt;Vec&lt;_&gt;&gt;(),
        image.array().with_new_value(raw),
    );

    Ok(IOValue::Image(wrap_with_unit))
&#125;

fn run_average(image: &amp;WcsArray, start: i64, end: i64) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    reduce_array_slice(image, start, end, |slices| slices.mean_axis(Axis(0)))
&#125;

fn run_variance(image: &amp;WcsArray, start: i64, end: i64) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    reduce_array_slice(image, start, end, |slices| slices.var_axis(Axis(0), 1.0))
&#125;

fn run_stddev(image: &amp;WcsArray, start: i64, end: i64) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    reduce_array_slice(image, start, end, |slices| slices.std_axis(Axis(0), 1.0))
&#125;

fn run_median(image: &amp;WcsArray, start: i64, end: i64) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    let start = try_into_unsigned!(start)?;
    let end = try_into_unsigned!(end)?;
    is_sliceable!(image, start, end)?;

    let image_val = image.scalar();

    let slices = image_val.slice_axis(Axis(0), Slice::from(start..end));
    let dim = slices.dim();
    let size = dim.as_array_view();
    let new_size: Vec&lt;_&gt; = size.iter().skip(1).cloned().collect();

    let result = ArrayD::from_shape_fn(new_size, |index| &#123;
        let mut vals = Vec::new();
        for (_, slice) in slices.axis_iter(Axis(0)).enumerate() &#123;
            vals.push(slice[&amp;index]);
        &#125;
        //consider NaN!
        vals.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let n = vals.len();
        if n % 2 == 1 &#123;
            vals[(n - 1) / 2]
        &#125; else &#123;
            (vals[n / 2] + vals[n / 2 - 1]) / 2.0
        &#125;
    &#125;);

    Ok(IOValue::Image(WcsArray::from_array(Dimensioned::new(
        result,
        Unit::None,
    ))))
&#125;
</code></pre>
<p><video src="images/00000046-aflak-improc-01/tw02.mp4" width="674" height="360" controls></video><br>これは平均を計算するノード（average ノード）を使った例です．3枚のデタラメなライトフレームを単純に加算平均してます．</p>
<p>これで位置合わせなしコンポジット機構もできましたので，<strong>位置合わせのいらない master dark や master flat をコンポジットするのはこのプログラムだけで完結できる</strong>ということになります．やったー．</p>
<h4 id="その3-リストへ変換"><a href="#その3-リストへ変換" class="headerlink" title="その3. リストへ変換"></a>その3. リストへ変換</h4><p>統計値計算をして得られるデータは二次元のデータです．各画素に，その位置の画素の統計値が入っています．ノイズ解析用 scatterplots ではこれらの統計値を横軸，縦軸の値として使用するため，<strong>一次元リストへ変換</strong>しておくと便利です．<br>ついでに常用対数を通した値にしておきます．</p>
<pre><code class="language-Rust">cake_transform!(
    &quot;Convert 2d image to 1d list.&quot;,
    1, 0, 0,
    convert_to_1d_image&lt;IOValue, IOErr&gt;(image: Image) -&gt; Image&#123;
        vec![run_convert_to_1d(image)]
    &#125;
),
cake_transform!(
    &quot;Convert to log10&quot;,
    1, 0, 0,
    log10&lt;IOValue, IOErr&gt;(image: Image) -&gt; Image &#123;
        vec![run_log10(image)]
    &#125;
),

fn run_convert_to_1d(image: &amp;WcsArray) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    dim_is!(image, 2)?;
    let image_val = image.scalar();

    let list_size = *image_val.dim().as_array_view().first().unwrap();
    let mut list = Vec::with_capacity(list_size);
    for i in 0..list_size &#123;
        for val in image_val.slice(s![i, ..]) &#123;
            list.push(*val);
        &#125;
    &#125;
    Ok(IOValue::Image(
        image.make_slice(
            &amp;[(2, 0.0, 1.0)],
            image
                .array()
                .with_new_value(Array1::from_vec(list).into_dyn()),
        ),
    ))
&#125;

fn run_log10(image: &amp;WcsArray) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    let mut out = image.clone();
    for v in out.scalar_mut().iter_mut() &#123;
        *v = v.log10();
    &#125;
    Ok(IOValue::Image(out))
&#125;
</code></pre>
<h4 id="その4-scatterplots-の描画"><a href="#その4-scatterplots-の描画" class="headerlink" title="その4. scatterplots の描画"></a>その4. scatterplots の描画</h4><p>これらの2つのリストから，scatterplots データを作っていきます．このプログラムでは<strong>様々な次元のデータを様々な形式で見られるようにしたい</strong>ので，最終データには「タグ文字列」を付加するようにしています．今回の場合，<strong>形状が (2, データ数) の “scatter” タグがついた二次元データをscatterplots と解釈して描画</strong>することになります．</p>
<pre><code class="language-Rust">cake_transform!(
    &quot;Create scatterplots from two 1D lists.&quot;,
    1, 0, 0,
    create_scatter&lt;IOValue, IOErr&gt;(xaxis: Image, yaxis: Image) -&gt; Image&#123;
        vec![run_create_scatter(xaxis, yaxis)]
    &#125;
),

fn run_create_scatter(xaxis: &amp;WcsArray, yaxis: &amp;WcsArray) -&gt; Result&lt;IOValue, IOErr&gt; &#123;
    dim_is!(xaxis, 1)?;
    dim_is!(yaxis, 1)?;
    are_same_dim!(xaxis, yaxis)?;
    let image_val = xaxis.scalar();
    let width = image_val.len();
    let mut img = Vec::with_capacity(2 * width);
    for i in 0..width &#123;
        for val in image_val.slice(s![i]) &#123;
            img.push(*val);
        &#125;
    &#125;
    let image_val = yaxis.scalar();
    for i in 0..width &#123;
        for val in image_val.slice(s![i]) &#123;
            img.push(*val);
        &#125;
    &#125;
    let mut datapoints = Vec::new();
    for i in 0..width &#123;
        datapoints.push((img[i], img[i + width]));
    &#125;
    datapoints.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut res = Vec::with_capacity(2 * width);
    for i in 0..width &#123;
        res.push(datapoints[i].0);
    &#125;
    for i in 0..width &#123;
        res.push(datapoints[i].1);
    &#125;
    let img = Array::from_shape_vec((2, width), res).unwrap();
    Ok(IOValue::Image(WcsArray::from_array_and_tag(
        Dimensioned::new(img.into_dyn(), Unit::None),
        Some(String::from(&quot;scatter&quot;)), //タグを付与するよ
    )))
&#125;
</code></pre>
<p>うーん．コードが汚い．ここはなんとかしたいですね…．<br>データポイントをとりあえずソートしています．これは描画を軽くするために必要なのですが，あとあとアルゴリズムを変えるかもしれません．<br>最後に scatterplots を描画してみます．ライブラリは <a target="_blank" rel="noopener" href="https://docs.rs/implot/0.3.0/implot/">implot</a> を利用．</p>
<pre><code class="language-Rust">Some(tag) =&gt; match tag.as_ref() &#123;
    &quot;scatter&quot; =&gt; match self.scalar().dim().ndim() &#123; //タグを認識するよ
        2 =&gt; &#123; //データは今のところ2次元に限定
            let state = &amp;mut ctx.window.scatter_lineplot_state;
            let plot_ui = ctx.plotcontext.get_plot_ui();
            if let Err(e) = ui.scatter(
                &amp;self.scalar2(),
                &amp;plot_ui,
                Some(&amp;AxisTransform::new(&quot;Median&quot;, &quot;&quot;, |x| x)),
                Some(&amp;AxisTransform::new(&quot;Standard Deviation&quot;, &quot;&quot;, |y| y)),
                state,
            ) &#123;
                ui.text(format!(&quot;Error on drawing plot! &#123;&#125;&quot;, e))
            &#125;
        &#125;
        _ =&gt; &#123;
            ui.text(format!(
                &quot;Unimplemented for scatter of dimension &#123;&#125;&quot;,
                self.scalar().ndim()
            ));
        &#125;
    &#125;,
&#125;

fn scatter&lt;S, FX, FY&gt;(
    &amp;self,
    image: &amp;ArrayBase&lt;S, Ix2&gt;,
    plot_ui: &amp;PlotUi,
    xaxis: Option&lt;&amp;AxisTransform&lt;FX&gt;&gt;,
    yaxis: Option&lt;&amp;AxisTransform&lt;FY&gt;&gt;,
    state: &amp;mut State,
) -&gt; Result&lt;(), Error&gt;
where
    S: Data&lt;Elem = f32&gt;,
    FX: Fn(f32) -&gt; f32,
    FY: Fn(f32) -&gt; f32,
&#123;
    let p = self.cursor_screen_pos();
    let window_pos = self.window_pos();
    let window_size = self.window_size();
    let size = [window_size[0], window_size[1] - (p[1] - window_pos[1])];
    state.simple_plot(self, image, &amp;plot_ui, xaxis, yaxis, size)
&#125;

pub(crate) fn simple_plot&lt;S, FX, FY&gt;(
    &amp;mut self,
    ui: &amp;Ui,
    image: &amp;ArrayBase&lt;S, Ix2&gt;,
    plot_ui: &amp;PlotUi,
    horizontal_axis: Option&lt;&amp;AxisTransform&lt;FX&gt;&gt;,
    vertical_axis: Option&lt;&amp;AxisTransform&lt;FY&gt;&gt;,
    size: [f32; 2],
) -&gt; Result&lt;(), Error&gt;
where
    S: Data&lt;Elem = f32&gt;,
    FX: Fn(f32) -&gt; f32,
    FY: Fn(f32) -&gt; f32,
&#123;
    let mut haxisname = &quot;&quot;;
    let mut vaxisname = &quot;&quot;;
    let mut haxisunit = &quot;&quot;;
    let mut vaxisunit = &quot;&quot;;
    if let Some(haxistrans) = horizontal_axis &#123;
        haxisname = haxistrans.label();
        haxisunit = haxistrans.unit();
    &#125;
    if let Some(vaxistrans) = vertical_axis &#123;
        vaxisname = vaxistrans.label();
        vaxisunit = vaxistrans.unit();
    &#125;
    let haxislabel = format!(&quot;&#123;&#125; (&#123;&#125;)&quot;, haxisname, haxisunit);
    let vaxislabel = format!(&quot;&#123;&#125; (&#123;&#125;)&quot;, vaxisname, vaxisunit);
    let size = [size[0] - 15.0, size[1] - 15.0];
    let xaxis = image.slice(s![0, ..]).to_vec();
    let yaxis = image.slice(s![1, ..]).to_vec();
    let mut datapoints = Vec::new();
    for i in 0..xaxis.len() &#123;
        datapoints.push((xaxis[i], yaxis[i]));
    &#125;
    let content_width = ui.window_content_region_width();
    let mut plot_limits: Option&lt;ImPlotLimits&gt; = None;

    Plot::new(&quot;Noise Analysis of Nikon D3, Median--Standard Deviation&quot;)
        .size(content_width, size[1])
        .x_label(&amp;haxislabel)
        .y_label(&amp;vaxislabel)
        .x_limits(&amp;ImPlotRange &#123; Min: 0.0, Max: 4.0 &#125;, Condition::FirstUseEver)
        .y_limits(
            &amp;ImPlotRange &#123; Min: 0.0, Max: 3.0 &#125;,
            YAxisChoice::First,
            Condition::FirstUseEver,
        )
        .build(plot_ui, || &#123;
            plot_limits = Some(get_plot_limits(None));
            let mut xaxis = Vec::new();
            let mut yaxis = Vec::new();
            if let Some(plot) = plot_limits &#123;
                let (xmin, xmax, ymin, ymax) = (plot.X.Min, plot.X.Max, plot.Y.Min, plot.Y.Max);
                datapoints.retain(|&amp;data| &#123;
                    xmin &lt;= data.0 as f64
                        &amp;&amp; data.0 as f64 &lt;= xmax
                        &amp;&amp; ymin &lt;= data.1 as f64
                        &amp;&amp; data.1 as f64 &lt;= ymax
                &#125;);
                let xstep = (xmax - xmin) / 50.0;
                let ystep = (ymax - ymin) / 50.0;
                datapoints.dedup_by(|a, b| &#123;
                    (a.0 - b.0).abs() &lt; xstep as f32 &amp;&amp; (a.1 - b.1).abs() &lt; ystep as f32
                &#125;);
                for datapoint in datapoints &#123;
                    xaxis.push(datapoint.0 as f64);
                    yaxis.push(datapoint.1 as f64);
                &#125;
            &#125; else &#123;
            &#125;
            PlotScatter::new(&quot;data point&quot;).plot(&amp;xaxis, &amp;yaxis);
        &#125;);
    Ok(())
&#125;
</code></pre>
<p>ソートされているので，dedup関数で近い位置のデータを削除して描画点を減らしているわけですが，dedup関数の仕様上思惑通りにはいきません．<strong>この関数は連続する要素しか見ないので，y軸の値が近いのデータペアを見つけられない</strong>ためです．ここは要改善です．<br>最終的には，こんな感じのデータが見られます．<br><video src="images/00000046-aflak-improc-01/tw03.mp4" width="674" height="360" controls></video><br><img src="/images/00000046-aflak-improc-01/tw01.jpg" alt="今回得られた結果">↑今回得られた散布図．↓あぷらなーとさんの結果<br><img src="/images/00000046-aflak-improc-01/tw02.png" alt="あぷらなーとさんの結果"></p>
<p>ある程度インタラクティブに拡大したり，移動したりといった操作ができるビューアができましたので今はこれで良しとしておきます．やったぜ．</p>
<p>全体のビジュアルプログラムはこんな感じ．少し複雑（？）ですが，<strong>上に書いた流れをそのまま表現</strong>しているだけです．<br><img src="/images/00000046-aflak-improc-01/02.jpg" alt="ダークノイズ解析のビジュアルプログラム"><br>例えばこのプログラムで「中央値画像を生成」の部分を「平均値画像を生成」するようなノードに変更すれば，横軸が平均値になったようなプロットを得たりといったことが<strong>誰でもコーディングなしで</strong>できるようになるわけです．どちらかの対数に変換するノードを消せば，片対数のプロットも作れたりします．以上！</p>
<h4 id="おまけ-Fitsデータのカラー画像解釈"><a href="#おまけ-Fitsデータのカラー画像解釈" class="headerlink" title="おまけ. Fitsデータのカラー画像解釈"></a>おまけ. Fitsデータのカラー画像解釈</h4><p>研究では輝度単一の値をカラーテーブルで変換することでしかデータを見てこなかったので，普通の天体画像のように3チャンネルあるような Fits データをカラー画像解釈できるようにしていきます．つまり，<strong>形状が (3, 画像横幅，画像縦幅) の “color_image” タグがついた三次元データをカラー画像と解釈して描画</strong>することになります．<br>チャンネル取り出しだけですが，<a target="_blank" rel="noopener" href="https://fornax.hateblo.jp/entry/20210103/1609605334">ぐらすのすちさんも似たようなこと</a>をやっています．</p>
<pre><code class="language-Rust">Some(tag) =&gt; match tag.as_ref() &#123;
    &quot;color_image&quot; =&gt; match self.scalar().dim().ndim() &#123;
        3 =&gt; &#123;
            /*省略*/
            if new_incoming_image &#123;
                /*省略*/
                if let Err(e) = state.set_color_image(
                    image_ref,
                    ctx.created_on,
                    ctx.gl_ctx,
                    texture_id,
                    ctx.textures,
                ) &#123;
                    ui.text(format!(&quot;Error on creating image! &#123;&#125;&quot;, e));
                &#125;
            &#125;
            if let Err(e) = ui.color_image(
                ctx.gl_ctx,
                ctx.textures,
                texture_id,
                unit,
                x_transform.as_ref(),
                y_transform.as_ref(),
                state,
            ) &#123;
                ui.text(format!(&quot;Error on drawing image! &#123;&#125;&quot;, e));
            &#125;
        &#125;
        _ =&gt; &#123;
            ui.text(format!(
                &quot;Unimplemented for color image of dimension &#123;&#125;&quot;,
                self.scalar().ndim()
            ));
        &#125;
    &#125;,
    _ =&gt; &#123;
        ui.text(format!(
            &quot;Unimplemented for visualization tag &#123;&#125;&quot;,
            self.scalar().ndim()
        ));
    &#125;
&#125;,

//state.set_color_image()の中身
pub fn set_color_image&lt;F&gt;(
    &amp;mut self,
    image: I,
    created_on: Instant,
    ctx: &amp;F,
    texture_id: TextureId,
    textures: &amp;mut Textures,
) -&gt; Result&lt;(), Error&gt;
where
    F: Facade,
&#123;
    self.image =
        image::Image::color_new(image, created_on, ctx, texture_id, textures, &amp;self.lut)?;
    Ok(())
&#125;

//image::Image::color_new()の中身
pub fn color_new&lt;F&gt;(
    image: I,
    created_on: Instant,
    ctx: &amp;F,
    texture_id: TextureId,
    textures: &amp;mut Textures,
    lut: &amp;ColorLUT,
) -&gt; Result&lt;Image&lt;I&gt;, Error&gt;
where
    F: Facade,
&#123;
    let (vmin, vmax, tex_size, hist) = &#123;
        let image = coerce_to_array_view3(&amp;image);
        let vmin = lims::get_vmin(&amp;image)?;
        let vmax = lims::get_vmax(&amp;image)?;
        let raw = make_raw_image_rgb(&amp;image, vmin, vmax, lut)?;
        let gl_texture = Texture2d::new(ctx, raw)?;
        let tex_size = gl_texture.dimensions();
        let tex_size = (tex_size.0 as f32, tex_size.1 as f32);
        textures.replace(
            texture_id,
            Texture &#123;
                texture: Rc::new(gl_texture),
                sampler: SamplerBehavior &#123;
                    ..Default::default()
                &#125;,
            &#125;,
        );
        let hist = hist::histogram_color(&amp;image, vmin, vmax);
        (vmin, vmax, tex_size, hist)
    &#125;;

    Ok(Image &#123;
        vmin,
        vmax,
        tex_size,
        created_on: Some(created_on),
        data: Some(image),
        hist,
    &#125;)
&#125;

//make_raw_image_rgb()の中身
fn make_raw_image_rgb&lt;S&gt;(
    image: &amp;ArrayBase&lt;S, Ix3&gt;,
    vmin: f32,
    vmax: f32,
    _lut: &amp;ColorLUT,
) -&gt; Result&lt;RawImage2d&lt;&#39;static, u8&gt;, Error&gt;
where
    S: Data&lt;Elem = f32&gt;,
&#123;
    let (_c, m, n) = image.dim();
    let mut data = Vec::with_capacity(3 * n * m);
    if !vmin.is_nan() &amp;&amp; !vmax.is_nan() &#123;
        for (_, slice) in image.axis_iter(Axis(1)).enumerate() &#123;
            for (_, channel) in slice.axis_iter(Axis(1)).enumerate() &#123;
                let r = channel[0] / 65535.0 * 255.0; //16bit -&gt; 8bit
                let g = channel[1] / 65535.0 * 255.0;
                let b = channel[2] / 65535.0 * 255.0;
                data.push(r as u8);
                data.push(g as u8);
                data.push(b as u8);
            &#125;
        &#125;
        Ok(RawImage2d &#123;
            data: Cow::Owned(data),
            width: n as u32,
            height: m as u32,
            format: ClientFormat::U8U8U8,
        &#125;)
    &#125; else &#123;
        Err(Error::Msg(&quot;vmin, vmax not set&quot;))
    &#125;
&#125;
//===============================================================================================================

//最初のコードのui.color_image()の中身
fn color_image&lt;F, FX, FY, I&gt;(
    &amp;self,
    _ctx: &amp;F,
    _textures: &amp;mut Textures,
    texture_id: TextureId,
    vunit: &amp;str,
    xaxis: Option&lt;&amp;AxisTransform&lt;FX&gt;&gt;,
    yaxis: Option&lt;&amp;AxisTransform&lt;FY&gt;&gt;,
    state: &amp;mut State&lt;I&gt;,
) -&gt; Result&lt;(), Error&gt;
where
    F: Facade,
    FX: Fn(f32) -&gt; f32,
    FY: Fn(f32) -&gt; f32,
    I: Borrow&lt;ArrayD&lt;f32&gt;&gt;,
&#123;
    let window_pos = self.window_pos();
    let cursor_pos = self.cursor_screen_pos();
    let window_size = self.window_size();
    const HIST_WIDTH: f32 = 40.0;
    const BAR_WIDTH: f32 = 20.0;
    const RIGHT_PADDING: f32 = 100.0;
    let image_max_size = (
        window_size[0] - HIST_WIDTH - BAR_WIDTH - RIGHT_PADDING,
        window_size[1] - (cursor_pos[1] - window_pos[1]),
    );
    let ([_p, _size], _x_label_height) =
        state.show_image(self, texture_id, vunit, xaxis, yaxis, image_max_size)?;
    Ok(())
&#125;

//state.show_image()の中身
pub(crate) fn show_image&lt;FX, FY&gt;(
    &amp;mut self,
    ui: &amp;Ui,
    texture_id: TextureId,
    vunit: &amp;str,
    xaxis: Option&lt;&amp;AxisTransform&lt;FX&gt;&gt;,
    yaxis: Option&lt;&amp;AxisTransform&lt;FY&gt;&gt;,
    max_size: (f32, f32),
) -&gt; Result&lt;([[f32; 2]; 2], f32), Error&gt;
where
    FX: Fn(f32) -&gt; f32,
    FY: Fn(f32) -&gt; f32,
&#123;
    /*省略*/
    ChildWindow::new(im_str!(&quot;scrolling_region&quot;))
        .border(false)
        .scroll_bar(false)
        .movable(false)
        .scrollable(false)
        .horizontal_scrollbar(false)
        .build(ui, || &#123;
            /*省略*/
            Image::new(texture_id, size).build(ui);
            /*1000行くらい省略…*/
        &#125;);
    /*省略*/
    Ok(([p, size], x_labels_height))
&#125;
</code></pre>
<p><img src="/images/00000046-aflak-improc-01/tw03.jpg" alt="カラー画像の表示"><br>カラー画像がでました！めでたしめでたし．</p>
<h3 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h3><p>とりあえず三が日を使って Raw データ処理のスタートアップができました．今後は<strong>位置合わせコンポジットやコンポジット後の単一画像の画像処理など，PixInsight も導入したのでアルゴリズムを勉強しながら実装</strong>していく予定です．モジュールを分割して具体例と一緒に提供することで，僕以外の方にも使っていただけるようなものが作れたらいいなあと思っています．また何か成果が出たら記事にしたいと思います．<br>それでは．</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/01/14/00000047-aflak-improc-02/" title="自作プログラムで画像処理（カラーヒストグラム表示～トーンカーブ作成まで）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 自作プログラムで画像処理（カラーヒストグラム表示～トーンカーブ作成まで）</span></a><a class="button is-default" href="/2020/12/29/00000045-2020-goals/" title="2020年の目標を振り返る"><span class="has-text-weight-semibold">Next: 2020年の目標を振り返る</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="dabokun/dabokun.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/astrodabo"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/dabokun"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> dabokun 2025</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>